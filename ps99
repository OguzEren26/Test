local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")

pcall(function()
   local menuGui = playerGui:FindFirstChild("MenuGui")
   if menuGui and menuGui:WaitForChild("UIToggles").Visible == false then
       game:GetService("ReplicatedStorage").LoadPlayer:FireServer()
   end
end)

local isFarming = false
local isAutoRetry = false
local isAutoAttack = false
local isAutoSpell = false
local isRenderDisabled = false
local isLootReset = false
local selectedMap = "Corrupted Forest"
local selectedDifficulty = 0
local selectedHP = 0
local isStartPressed = false
local isSpellDelay = false
local isSellPressed = false
local savedSelectedTypes = {}
local savedSelectedRarities = {}
local mobDistance = 20

local function ensureSaveFolder()
   if not isfolder("kinayosaving") then
       makefolder("kinayosaving")
   end
end

local function saveSettings()
    ensureSaveFolder()
    local raritiesArray = {}
    for rarity, _ in pairs(savedSelectedRarities) do
        table.insert(raritiesArray, rarity)
    end
    
    local settings = {
        autoRetry = isAutoRetry,
        autoAttack = isAutoAttack,
        autoSpell = isAutoSpell,
        farming = isFarming,
        renderDisabled = isRenderDisabled,
        lootReset = isLootReset,
        difficulty = selectedDifficulty,
        spellDelay = isSpellDelay,
        hp = selectedHP,
        startPressed = isStartPressed,
        map = selectedMap,
        sellPressed = isSellPressed,
        selectedTypes = savedSelectedTypes,
        selectedRarities = raritiesArray,
        mobDistance = mobDistance,
    }
    writefile("kinayosaving/settings.json", game:GetService("HttpService"):JSONEncode(settings))
end

local function loadSettings()
 ensureSaveFolder()
 if isfile("kinayosaving/settings.json") then
     local settings = game:GetService("HttpService"):JSONDecode(readfile("kinayosaving/settings.json"))
     isAutoRetry = settings.autoRetry or false
     isAutoAttack = settings.autoAttack or false
     isAutoSpell = settings.autoSpell or false
     isFarming = settings.farming or false
     isRenderDisabled = settings.renderDisabled or false
     isLootReset = settings.lootReset or false
     selectedDifficulty = settings.difficulty or 0
     isSpellDelay = settings.spellDelay or false
     selectedHP = settings.hp or 0
     isStartPressed = settings.startPressed or false
     selectedMap = settings.map or "Corrupted Forest"
     isSellPressed = settings.sellPressed or false
     savedSelectedTypes = settings.selectedTypes or {}
     savedSelectedRarities = {}
     mobDistance = settings.mobDistance or 20
     
     for _, rarity in ipairs(settings.selectedRarities or {}) do
         savedSelectedRarities[rarity] = true
     end
     
     if DistanceLabel then
         DistanceLabel.Text = "Mob Distance: " .. mobDistance
     end
     if SliderButton then
         local percentage = (mobDistance - 5) / 15
         SliderButton.Position = UDim2.new(percentage, -6, 0.5, -6)
     end
 end
end

local function shouldAttackFellOak(enemiesFolder)
   local roomText = game:GetService("Players").LocalPlayer.PlayerGui.BaseGui.Timer.Clock.Inner.Room.Text
   if roomText ~= "Room 4/6" then
       return false
   end
   
   for _, enemy in ipairs(enemiesFolder:GetChildren()) do
       if enemy:IsA("Model") and 
          enemy.Name ~= "Ancient Fell Oak" and 
          enemy.Name ~= "Corrupted Bandit" and 
          enemy.Name ~= "Defeated" and 
          enemy.Name ~= "Depleted Crystal" then
           return false
       end
   end
   
   return true
end

local function castSpells()
   while isFarming and isAutoSpell do
       if game:GetService("ReplicatedStorage"):FindFirstChild("Start") then
           local player = game.Players.LocalPlayer
           local character = player.Character
           if character then
               local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
               if humanoidRootPart then
                   local enemiesFolder = game:GetService("Workspace").Enemies
                   if enemiesFolder then
                       local nearestEnemy = nil
                       local shortestDistance = math.huge
                       
                       for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                           if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                               local distance = (humanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                               if distance < shortestDistance and enemy.Name ~= "Defeated" and enemy.Name ~= "Depleted Crystal" then
                                   shortestDistance = distance
                                   nearestEnemy = enemy
                               end
                           end
                       end
                       
                       local spellDistance = 30
                       if nearestEnemy and (nearestEnemy.Name == "Ancient Fell Oak" or nearestEnemy.Name == "Corrupting Crystal") then
                           spellDistance = 50
                       end
                       
                       if nearestEnemy and shortestDistance <= spellDistance then
                           for i = 1, 4 do
                               local args = {
    [1] = "Spell" .. i,
    [2] = nearestEnemy.HumanoidRootPart.Position,
    [3] = Vector3.new(0, 0, 0),
    [4] = isSpellDelay and 1.5 or 0
}
                               game:GetService("ReplicatedStorage").Spell:FireServer(unpack(args))
                           end
                       end
                   end
               end
           end
       end
       task.wait(0.1)
   end
end

local function autoAttack()
   while isFarming and isAutoAttack do
       if game:GetService("ReplicatedStorage"):FindFirstChild("Start") then
           local player = game.Players.LocalPlayer
           local character = player.Character
           if character then
               local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
               if humanoidRootPart then
                   local enemiesFolder = game:GetService("Workspace").Enemies
                   if enemiesFolder then
                       local nearestEnemy = nil
                       local shortestDistance = math.huge
                       
                       for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                           if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                               local distance = (humanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                               if distance < shortestDistance and enemy.Name ~= "Defeated" and enemy.Name ~= "Depleted Crystal" then
                                   shortestDistance = distance
                                   nearestEnemy = enemy
                               end
                           end
                       end
                       
                       local attackDistance = 30
                       if nearestEnemy and (nearestEnemy.Name == "Ancient Fell Oak" or nearestEnemy.Name == "Corrupting Crystal") then
                           attackDistance = 50
                       end
                       
                       if nearestEnemy and shortestDistance <= attackDistance then
                           local args = {
                               [1] = true
                           }
                           game:GetService("ReplicatedStorage").Click:FireServer(unpack(args))
                       end
                   end
               end
           end
       end
       task.wait(0.1)
   end
end

local function getEnemiesCount()
   local enemiesText = game:GetService("Players").LocalPlayer.PlayerGui.BaseGui.Timer.Clock.Inner.Enemies.Text
   return tonumber(enemiesText:match("(%d+)"))
end

local visitedCheckpoints = {}
local visitedSecondaryCheckpoints = {}
local visitedTertiaryCheckpoints = {}

local checkpoints = {
   Vector3.new(98, 29, -1205),
   Vector3.new(23, 36, -1265)
}

local secondaryCheckpoints = {
   Vector3.new(-31, 61, -1130),
   Vector3.new(-47, 61, -1206),
   Vector3.new(-52, 61, -1350)
}

local tertiaryCheckpoints = {
   Vector3.new(-84, 61, -1303),
   Vector3.new(-78, 61, -1337)
}

local function moveToNearestEnemy()
  local player = game.Players.LocalPlayer
  local character = player.Character or player.CharacterAdded:Wait()
  local humanoidRootPart = character:WaitForChild("HumanoidRootPart") 
  local humanoid = character:WaitForChild("Humanoid")
  local pathfindingService = game:GetService("PathfindingService")
  local specialCheckpoint = Vector3.new(23, 124, -1450)

  local function checkEnemyValid(enemy)
      return enemy and enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and enemy.Parent and enemy.Name ~= "Defeated" and enemy.Name ~= "Depleted Crystal"
  end

  local function processCheckpoints(points, visitedPoints, enemiesFolder)
      for i, checkpoint in ipairs(points) do
          if not visitedPoints[i] then
              humanoid:MoveTo(checkpoint)
              humanoid.MoveToFinished:Wait()
              visitedPoints[i] = true
              
              local nearestEnemy = nil
              local shortestDistance = math.huge
              
              for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                  if checkEnemyValid(enemy) then
                      local distance = (humanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                      if distance < shortestDistance then
                          shortestDistance = distance
                          nearestEnemy = enemy
                      end
                  end
              end
              
              if nearestEnemy and checkEnemyValid(nearestEnemy) then
                  local path = pathfindingService:CreatePath({
                      AgentRadius = 0.1,
                      AgentHeight = 1,
                      AgentCanJump = true
                  })
                  
                  local success = pcall(function()
                      path:ComputeAsync(humanoidRootPart.Position, nearestEnemy.HumanoidRootPart.Position)
                  end)
                  
                  if success and path.Status == Enum.PathStatus.Success then
                      return nearestEnemy, shortestDistance
                  end
              end
          end
      end
      return nil, math.huge
  end

  game.Players.LocalPlayer.CharacterAdded:Connect(function()
      table.clear(visitedCheckpoints)
      table.clear(visitedSecondaryCheckpoints)
      table.clear(visitedTertiaryCheckpoints)
  end)

  while isFarming do
      local enemiesFolder = game:GetService("Workspace").Enemies
      if not enemiesFolder then 
          task.wait(0.1)
          continue 
      end

      local roomText = game:GetService("Players").LocalPlayer.PlayerGui.BaseGui.Timer.Clock.Inner.Room.Text
      local enemiesCount = getEnemiesCount()
      
      if roomText == "Room 5/6" and enemiesCount == 11 then
          humanoid:MoveTo(specialCheckpoint)
          humanoid.MoveToFinished:Wait()
      end

      local isRoom5 = roomText == "Room 5/6"
      local canAttackFellOak = shouldAttackFellOak(enemiesFolder)
      
      local function findNearestEnemy()
          local nearestEnemy = nil
          local shortestDistance = math.huge

          for _, enemy in ipairs(enemiesFolder:GetChildren()) do
              if checkEnemyValid(enemy) then
                  if enemy.Name ~= "Ancient Fell Oak" or canAttackFellOak then
                      local distance = (humanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                      if distance < shortestDistance then
                          shortestDistance = distance
                          nearestEnemy = enemy
                      end
                  end
              end
          end
          
          return nearestEnemy, shortestDistance
      end
      
      local nearestEnemy, shortestDistance = findNearestEnemy()

      if nearestEnemy and checkEnemyValid(nearestEnemy) then
          local path = pathfindingService:CreatePath({
              AgentRadius = 0.1,
              AgentHeight = 1,
              AgentCanJump = true
          })
          
          local success = pcall(function()
              path:ComputeAsync(humanoidRootPart.Position, nearestEnemy.HumanoidRootPart.Position)
          end)

          if not success or path.Status ~= Enum.PathStatus.Success then
              if isRoom5 then
                  if enemiesCount and enemiesCount <= 14 then
                      nearestEnemy, shortestDistance = processCheckpoints(tertiaryCheckpoints, visitedTertiaryCheckpoints, enemiesFolder)
                  else
                      nearestEnemy, shortestDistance = processCheckpoints(checkpoints, visitedCheckpoints, enemiesFolder)
                      if not nearestEnemy then
                          nearestEnemy, shortestDistance = processCheckpoints(secondaryCheckpoints, visitedSecondaryCheckpoints, enemiesFolder)
                      end
                  end
              end
              if not nearestEnemy then
                  task.wait(0.1)
                  continue
              end
          end

          if nearestEnemy and checkEnemyValid(nearestEnemy) then
              local enemyPosition = nearestEnemy.HumanoidRootPart.Position
              local direction = (enemyPosition - humanoidRootPart.Position).Unit
              humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(enemyPosition.X, humanoidRootPart.Position.Y, enemyPosition.Z))

              if nearestEnemy.Name == "Corrupting Crystal" then
                  local targetPosition = nearestEnemy.HumanoidRootPart.Position
                  humanoid:MoveTo(targetPosition)
              elseif nearestEnemy.Name == "Bandit Lord" then
                  if shortestDistance > mobDistance then
                      local bandidPath = pathfindingService:CreatePath({
                          AgentRadius = 0.1,
                          AgentHeight = 1,
                          AgentCanJump = true
                      })
                      
                      local bandidSuccess = pcall(function()
                          bandidPath:ComputeAsync(humanoidRootPart.Position, nearestEnemy.HumanoidRootPart.Position)
                      end)
                      
                      if bandidSuccess and bandidPath.Status == Enum.PathStatus.Success then
                          for _, waypoint in ipairs(bandidPath:GetWaypoints()) do
                              if not isFarming then break end
                              if checkEnemyValid(nearestEnemy) then
                                  humanoid:MoveTo(waypoint.Position)
                                  humanoid.MoveToFinished:Wait()
                              else
                                  break
                              end
                          end
                      end
                  end
                  if checkEnemyValid(nearestEnemy) then
                      local enemyPosition = nearestEnemy.HumanoidRootPart.Position
                      humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(enemyPosition.X, humanoidRootPart.Position.Y, enemyPosition.Z))
                  end
              elseif nearestEnemy.Name == "Ancient Fell Oak" then
                  local targetPosition = nearestEnemy.HumanoidRootPart.Position + Vector3.new(25, 0, 0)
                  humanoid:MoveTo(targetPosition)
              elseif nearestEnemy.Name == "Timelost Sorcerer" then
                  if shortestDistance < 5 then
                      local rightVector = humanoidRootPart.CFrame.RightVector
                      local targetPosition = enemyPosition - direction * 5 + rightVector * -5
                      humanoid:MoveTo(targetPosition)
                  else
                      local sorcererPath = pathfindingService:CreatePath({
                          AgentRadius = 0.1,
                          AgentHeight = 1,
                          AgentCanJump = true
                      })
                      
                      local sorcererSuccess = pcall(function()
                          sorcererPath:ComputeAsync(humanoidRootPart.Position, nearestEnemy.HumanoidRootPart.Position)
                      end)
                      
                      if sorcererSuccess and sorcererPath.Status == Enum.PathStatus.Success then
                          for _, waypoint in ipairs(sorcererPath:GetWaypoints()) do
                              if not isFarming then break end
                              if checkEnemyValid(nearestEnemy) then
                                  local currentDistance = (humanoidRootPart.Position - nearestEnemy.HumanoidRootPart.Position).Magnitude
                                  if currentDistance < 5 then
                                      local rightVector = humanoidRootPart.CFrame.RightVector
                                      local targetPosition = enemyPosition - direction * 5 + rightVector * -5
                                      humanoid:MoveTo(targetPosition)
                                      break
                                  end
                                  humanoid:MoveTo(waypoint.Position)
                                  humanoid.MoveToFinished:Wait()
                              else
                                  break
                              end
                          end
                      end
                  end
              else
                  if shortestDistance < mobDistance then
                      local rightVector = humanoidRootPart.CFrame.RightVector
                      local targetPosition = enemyPosition - direction * mobDistance + rightVector * -5
                      humanoid:MoveTo(targetPosition)
                  else
                      local mobPath = pathfindingService:CreatePath({
                          AgentRadius = 0.1,
                          AgentHeight = 1,
                          AgentCanJump = true
                      })
                      
                      local mobSuccess = pcall(function()
                          mobPath:ComputeAsync(humanoidRootPart.Position, nearestEnemy.HumanoidRootPart.Position)
                      end)
                      
                      if mobSuccess and mobPath.Status == Enum.PathStatus.Success then
                          for _, waypoint in ipairs(mobPath:GetWaypoints()) do
                              if not isFarming then break end
                              if checkEnemyValid(nearestEnemy) then
                                  local currentDistance = (humanoidRootPart.Position - nearestEnemy.HumanoidRootPart.Position).Magnitude
                                  if currentDistance < mobDistance then
                                      local rightVector = humanoidRootPart.CFrame.RightVector
                                      local targetPosition = enemyPosition - direction * mobDistance + rightVector * -5
                                      humanoid:MoveTo(targetPosition)
                                      break
                                  end
                                  humanoid:MoveTo(waypoint.Position)
                                  humanoid.MoveToFinished:Wait()
                              else
                                  break
                              end
                          end
                      end
                  end
              end
          end
      else
          if isRoom5 then
              if enemiesCount and enemiesCount <= 14 then
                  nearestEnemy, shortestDistance = processCheckpoints(tertiaryCheckpoints, visitedTertiaryCheckpoints, enemiesFolder)
              else
                  nearestEnemy, shortestDistance = processCheckpoints(checkpoints, visitedCheckpoints, enemiesFolder)
                  if not nearestEnemy then
                      nearestEnemy, shortestDistance = processCheckpoints(secondaryCheckpoints, visitedSecondaryCheckpoints, enemiesFolder)
                  end
              end
          end
          task.wait(0.1)
          continue
      end
      
      task.wait(0)
      
      if not checkEnemyValid(nearestEnemy) then
          task.wait(0.1)
          continue
      end
  end
end

local function getEquippedAndPinnedItems()
  local equipped = {}
  local playerInventory = workspace.Inventories[game.Players.LocalPlayer.Name]
  
  local slots = {"Weapon", "Leggings", "Armor", "Helmet", "Emblem", "Spell1", "Spell2"}
  
  for _, slot in ipairs(slots) do
      local equippedItem = playerInventory:FindFirstChild(slot)
      if equippedItem and equippedItem:IsA("StringValue") then
          equipped[equippedItem.Value] = true
      end
  end
  
  for _, item in pairs(playerInventory.Items:GetChildren()) do
      if item:IsA("StringValue") then
          local values = item.Value:split(",")
          if values[#values] == "1" then
              equipped[item.Name] = true
          end
      end
  end
  
  return equipped
end

local function updateRenderState()
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    local kinayoScripts = playerGui:WaitForChild("KinayoScripts")
    local blackOverlay = kinayoScripts:FindFirstChild("BlackOverlay")
    
    if isFarming and isRenderDisabled then
        game:GetService("RunService"):Set3dRenderingEnabled(false)
        if blackOverlay then
            blackOverlay.Visible = true
        end
    else
        game:GetService("RunService"):Set3dRenderingEnabled(true)
        if blackOverlay then
            blackOverlay.Visible = false
        end
    end
end

local function startFarming()
    if isFarming then
        if game:GetService("ReplicatedStorage"):FindFirstChild("Start") then
            game:GetService("ReplicatedStorage").Start:FireServer()
            task.spawn(function()
                task.wait(3)
                local screenGui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("KinayoScripts")
                if screenGui then
                    local mainFrame = screenGui:FindFirstChild("MainFrame")
                    if mainFrame then
                        mainFrame.Visible = false
                    end
                end
            end)
            
            task.spawn(moveToNearestEnemy)
            if isAutoAttack then
                task.spawn(autoAttack)
            end
            if isAutoSpell then
                task.spawn(castSpells)
            end
        end
        updateRenderState()
    end
end

local Player = game.Players.LocalPlayer
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KinayoScripts"
ScreenGui.Parent = Player.PlayerGui
ScreenGui.ResetOnSpawn = false
ScreenGui.DisplayOrder = 999999999
ScreenGui.IgnoreGuiInset = true

local BlackOverlay = Instance.new("Frame")
BlackOverlay.Name = "BlackOverlay"
BlackOverlay.Size = UDim2.new(1, 0, 1, 0)
BlackOverlay.Position = UDim2.new(0, 0, 0, 0)
BlackOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
BlackOverlay.BackgroundTransparency = 0
BlackOverlay.Visible = false
BlackOverlay.Parent = ScreenGui

local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Size = UDim2.new(0, 30, 0, 30)
ToggleButton.Position = UDim2.new(0.5, -15, 0, 5)
ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ToggleButton.BackgroundTransparency = 0.4
ToggleButton.Parent = ScreenGui
ToggleButton.Text = "K"
ToggleButton.Font = Enum.Font.SourceSansBold
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 18

local UICorner_Toggle = Instance.new("UICorner")
UICorner_Toggle.CornerRadius = UDim.new(1, 0)
UICorner_Toggle.Parent = ToggleButton

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 240, 0, 220)
MainFrame.Position = UDim2.new(0.5, -120, 0.5, -110)
MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
MainFrame.BackgroundTransparency = 0.4
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local MainStroke = Instance.new("UIStroke")
MainStroke.Color = Color3.fromRGB(147, 112, 219)
MainStroke.Thickness = 2
MainStroke.Parent = MainFrame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 12)
UICorner.Parent = MainFrame

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(1, 0, 0, 20)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Kinayo Scripts"
Title.Font = Enum.Font.SourceSansBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.Parent = MainFrame

local SubTitle = Instance.new("TextLabel")
SubTitle.Name = "SubTitle"
SubTitle.Size = UDim2.new(1, 0, 0, 15)
SubTitle.Position = UDim2.new(0, 0, 0.1, 0)
SubTitle.BackgroundTransparency = 1
SubTitle.Text = "Arcane Conquest"
SubTitle.Font = Enum.Font.SourceSansItalic
SubTitle.TextColor3 = Color3.fromRGB(200, 200, 200)
SubTitle.TextSize = 14
SubTitle.Parent = MainFrame

local DiscordButton = Instance.new("TextButton")
DiscordButton.Name = "DiscordButton"
DiscordButton.Size = UDim2.new(0, 40, 0, 20)
DiscordButton.Position = UDim2.new(1, -45, 0, 5)
DiscordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
DiscordButton.BackgroundTransparency = 0.2
DiscordButton.Text = "Discord"
DiscordButton.Font = Enum.Font.Gotham
DiscordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DiscordButton.TextSize = 12
DiscordButton.Parent = MainFrame

local UICorner_Discord = Instance.new("UICorner")
UICorner_Discord.CornerRadius = UDim.new(0, 6)
UICorner_Discord.Parent = DiscordButton

local function createButton(name, pos)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(0.45, 0, 0, 25)
    button.Position = pos
    button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
    button.BackgroundTransparency = 0.6
    button.Text = name
    button.Font = Enum.Font.Gotham
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 12
    button.Parent = MainFrame

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button

    return button
end

local FarmButton = createButton("Auto Farm", UDim2.new(0.03, 0, 0.20, 0))
local AutoAttackButton = createButton("Auto Attack", UDim2.new(0.52, 0, 0.20, 0))
local RetryButton = createButton("Auto Retry", UDim2.new(0.03, 0, 0.35, 0))
local AutoSpellButton = createButton("Auto Spell", UDim2.new(0.52, 0, 0.35, 0))
local RenderButton = createButton("Disable Render", UDim2.new(0.03, 0, 0.50, 0))
local LootResetButton = createButton("Loot Reset", UDim2.new(0.52, 0, 0.50, 0))
local AutoJoinButton = createButton("Auto Join", UDim2.new(0.03, 0, 0.65, 0))
local AutoSellButton = createButton("Auto Sell", UDim2.new(0.52, 0, 0.65, 0))
local SpellDelayButton = createButton("Hold Skills", UDim2.new(0.03, 0, 0.80, 0))

local JoinFrame = Instance.new("Frame")
JoinFrame.Name = "JoinFrame"
JoinFrame.Size = UDim2.new(0, 180, 0, 140)
JoinFrame.Position = UDim2.new(1.05, 0, 0, 0)
JoinFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
JoinFrame.BackgroundTransparency = 0.4
JoinFrame.BorderSizePixel = 0
JoinFrame.Visible = false
JoinFrame.Parent = MainFrame

local JoinStroke = Instance.new("UIStroke")
JoinStroke.Color = Color3.fromRGB(147, 112, 219)
JoinStroke.Thickness = 2
JoinStroke.Parent = JoinFrame

local UICorner_Join = Instance.new("UICorner")
UICorner_Join.CornerRadius = UDim.new(0, 12)
UICorner_Join.Parent = JoinFrame

local MapButton = Instance.new("TextButton")
MapButton.Name = "MapButton"
MapButton.Size = UDim2.new(0.9, 0, 0, 25)
MapButton.Position = UDim2.new(0.05, 0, 0.05, 0)
MapButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
MapButton.BackgroundTransparency = 0.6
MapButton.Text = "Map: Corrupted Forest"
MapButton.Font = Enum.Font.Gotham
MapButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MapButton.TextSize = 12
MapButton.Parent = JoinFrame

local UICorner_Map = Instance.new("UICorner")
UICorner_Map.CornerRadius = UDim.new(0, 8)
UICorner_Map.Parent = MapButton

local DifficultyButton = Instance.new("TextButton")
DifficultyButton.Name = "DifficultyButton"
DifficultyButton.Size = UDim2.new(0.9, 0, 0, 25)
DifficultyButton.Position = UDim2.new(0.05, 0, 0.3, 0)
DifficultyButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
DifficultyButton.BackgroundTransparency = 0.6
DifficultyButton.Text = "Difficulty: Basic"
DifficultyButton.Font = Enum.Font.Gotham
DifficultyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DifficultyButton.TextSize = 12
DifficultyButton.Parent = JoinFrame

local UICorner_Difficulty = Instance.new("UICorner")
UICorner_Difficulty.CornerRadius = UDim.new(0, 8)
UICorner_Difficulty.Parent = DifficultyButton

local HPButton = Instance.new("TextButton")
HPButton.Name = "HPButton"
HPButton.Size = UDim2.new(0.9, 0, 0, 25)
HPButton.Position = UDim2.new(0.05, 0, 0.55, 0)
HPButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
HPButton.BackgroundTransparency = 0.6
HPButton.Text = "HP: Infinite"
HPButton.Font = Enum.Font.Gotham
HPButton.TextColor3 = Color3.fromRGB(255, 255, 255)
HPButton.TextSize = 12
HPButton.Parent = JoinFrame

local UICorner_HP = Instance.new("UICorner")
UICorner_HP.CornerRadius = UDim.new(0, 8)
UICorner_HP.Parent = HPButton

local StartButton = Instance.new("TextButton")
StartButton.Name = "StartButton"
StartButton.Size = UDim2.new(0.9, 0, 0, 25)
StartButton.Position = UDim2.new(0.05, 0, 0.8, 0)
StartButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
StartButton.BackgroundTransparency = 0.6
StartButton.Text = "Start"
StartButton.Font = Enum.Font.Gotham
StartButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StartButton.TextSize = 12
StartButton.Parent = JoinFrame

local UICorner_Start = Instance.new("UICorner")
UICorner_Start.CornerRadius = UDim.new(0, 8)
UICorner_Start.Parent = StartButton

local SellFrame = Instance.new("Frame")
SellFrame.Name = "SellFrame"
SellFrame.Size = UDim2.new(0, 180, 0, 140)
SellFrame.Position = UDim2.new(1.05, 0, 0, 0)
SellFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
SellFrame.BackgroundTransparency = 0.4
SellFrame.BorderSizePixel = 0
SellFrame.Visible = false
SellFrame.Parent = MainFrame

local SellStroke = Instance.new("UIStroke")
SellStroke.Color = Color3.fromRGB(147, 112, 219)
SellStroke.Thickness = 2
SellStroke.Parent = SellFrame

local UICorner_Sell = Instance.new("UICorner")
UICorner_Sell.CornerRadius = UDim.new(0, 12)
UICorner_Sell.Parent = SellFrame

local TypeFrame = Instance.new("Frame")
TypeFrame.Name = "TypeFrame"
TypeFrame.BackgroundTransparency = 1
TypeFrame.Position = UDim2.new(0, 5, 0, 5)
TypeFrame.Size = UDim2.new(1, -10, 0, 60)
TypeFrame.Parent = SellFrame

local RarityFrame = Instance.new("Frame")
RarityFrame.Name = "RarityFrame"
RarityFrame.BackgroundTransparency = 1
RarityFrame.Position = UDim2.new(0, 5, 0, 70)
RarityFrame.Size = UDim2.new(1, -10, 0, 30)
RarityFrame.Parent = SellFrame

loadSettings()

local DistanceFrame = Instance.new("Frame")
DistanceFrame.Name = "DistanceFrame"
DistanceFrame.Size = UDim2.new(0.9, 0, 0, 40)
DistanceFrame.Position = UDim2.new(0.05, 0, 0.82, 0)
DistanceFrame.BackgroundTransparency = 1
DistanceFrame.Parent = MainFrame

local DistanceLabel = Instance.new("TextLabel")
DistanceLabel.Name = "DistanceLabel"
DistanceLabel.Size = UDim2.new(1, 0, 0, 20)
DistanceLabel.Position = UDim2.new(0, 0, 0, 0)
DistanceLabel.BackgroundTransparency = 1
DistanceLabel.Text = "Mob Distance: " .. mobDistance
DistanceLabel.Font = Enum.Font.Gotham
DistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
DistanceLabel.TextSize = 12
DistanceLabel.TextXAlignment = Enum.TextXAlignment.Right
DistanceLabel.Parent = DistanceFrame

local SliderFrame = Instance.new("Frame")
SliderFrame.Name = "SliderFrame"
SliderFrame.Size = UDim2.new(1, 0, 0, 4)
SliderFrame.Position = UDim2.new(0, 0, 0.6, 0)
SliderFrame.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
SliderFrame.BackgroundTransparency = 0.6
SliderFrame.Parent = DistanceFrame

local UICorner_Slider = Instance.new("UICorner")
UICorner_Slider.CornerRadius = UDim.new(0, 2)
UICorner_Slider.Parent = SliderFrame

local SliderButton = Instance.new("TextButton")
SliderButton.Name = "SliderButton"
SliderButton.Size = UDim2.new(0, 12, 0, 12)
SliderButton.Position = UDim2.new((mobDistance - 5) / 15, -6, 0.5, -6)
SliderButton.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
SliderButton.Text = ""
SliderButton.Parent = SliderFrame

local UICorner_SliderButton = Instance.new("UICorner")
UICorner_SliderButton.CornerRadius = UDim.new(1, 0)
UICorner_SliderButton.Parent = SliderButton

SpellDelayButton.MouseButton1Click:Connect(function()
   isSpellDelay = not isSpellDelay
   SpellDelayButton.BackgroundColor3 = isSpellDelay and Color3.fromRGB(160, 80, 255) or Color3.fromRGB(100, 50, 200)
   saveSettings()
end)

local function updateSlider(pos)
    local sliderPos = pos - SliderFrame.AbsolutePosition.X
    local sliderSize = SliderFrame.AbsoluteSize.X
    local percentage = math.clamp(sliderPos / sliderSize, 0, 1)
    mobDistance = math.floor(percentage * 15 + 5)
    DistanceLabel.Text = "Mob Distance: " .. mobDistance
    SliderButton.Position = UDim2.new(percentage, -6, 0.5, -6)
    saveSettings()
end

local isDragging = false

SliderButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or 
       input.UserInputType == Enum.UserInputType.Touch then
        isDragging = true
    end
end)

game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or 
       input.UserInputType == Enum.UserInputType.Touch then
        isDragging = false
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if isDragging and 
       (input.UserInputType == Enum.UserInputType.MouseMovement or 
        input.UserInputType == Enum.UserInputType.Touch) then
        updateSlider(input.Position.X)
    end
end)

SliderFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or 
       input.UserInputType == Enum.UserInputType.Touch then
        updateSlider(input.Position.X)
        isDragging = true
    end
end)

local selectedTypes = {}
local selectedRarities = {}

local function createTypeButton(name, posX, posY)
   local button = Instance.new("TextButton")
   button.Size = UDim2.new(0, 50, 0, 25)
   button.Position = UDim2.new(0, posX, 0, posY)
   button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
   button.BackgroundTransparency = 0.6
   button.Text = name
   button.TextSize = 9
   button.Font = Enum.Font.Gotham
   button.TextColor3 = Color3.fromRGB(255, 255, 255)
   button.Parent = TypeFrame

   local UICorner = Instance.new("UICorner")
   UICorner.CornerRadius = UDim.new(0, 8)
   UICorner.Parent = button
   
   button.MouseButton1Click:Connect(function()
       if selectedTypes[name] then
           selectedTypes[name] = nil
           savedSelectedTypes[name] = nil
           button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
       else
           selectedTypes[name] = true
           savedSelectedTypes[name] = true
           button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
       end
       saveSettings()
   end)
   
   if savedSelectedTypes[name] then
       selectedTypes[name] = true
       button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
   end
   
   return button
end

local function createRarityButton(name, rarity, posX)
   local button = Instance.new("TextButton")
   button.Size = UDim2.new(0, 22, 0, 25)
   button.Position = UDim2.new(0, posX, 0, 0)
   button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
   button.BackgroundTransparency = 0.6
   button.Text = string.sub(name, 1, 1)
   button.TextSize = 9
   button.Font = Enum.Font.Gotham
   button.TextColor3 = Color3.fromRGB(255, 255, 255)
   button.Parent = RarityFrame

   local UICorner = Instance.new("UICorner")
   UICorner.CornerRadius = UDim.new(0, 8)
   UICorner.Parent = button
   
   button.MouseButton1Click:Connect(function()
       if selectedRarities[rarity] then
           selectedRarities[rarity] = nil
           savedSelectedRarities[rarity] = nil
           button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
       else
           selectedRarities[rarity] = true
           savedSelectedRarities[rarity] = true
           button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
       end
       saveSettings()
   end)
   
   if savedSelectedRarities[rarity] then
       selectedRarities[rarity] = true
       button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
   end
   
   return button
end

createTypeButton("Weapon", 5, 0)
createTypeButton("Leggings", 60, 0)
createTypeButton("Armor", 115, 0)
createTypeButton("Helmet", 5, 30)
createTypeButton("Spell", 60, 30)
createTypeButton("Emblem", 115, 30)

createRarityButton("Common", 1, 5)
createRarityButton("Uncommon", 2, 30)
createRarityButton("Rare", 3, 55)
createRarityButton("Epic", 4, 80)
createRarityButton("Legendary", 5, 105)
createRarityButton("Mythic", 6, 130)
createRarityButton("Fabled", 7, 155)

local SellButton = Instance.new("TextButton")
SellButton.Size = UDim2.new(0.9, 0, 0, 25)
SellButton.Position = UDim2.new(0.05, 0, 0.8, 0)
SellButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
SellButton.BackgroundTransparency = 0.6
SellButton.Text = "SELL"
SellButton.TextSize = 12
SellButton.Font = Enum.Font.Gotham
SellButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SellButton.Parent = SellFrame

local UICorner_SellButton = Instance.new("UICorner")
UICorner_SellButton.CornerRadius = UDim.new(0, 8)
UICorner_SellButton.Parent = SellButton

local function updateButtonStates()
   for _, button in ipairs(TypeFrame:GetChildren()) do
       if button:IsA("TextButton") then
           if savedSelectedTypes[button.Text] then
               button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
               selectedTypes[button.Text] = true
           end
       end
   end
   
   local rarityMap = {
       ["C"] = 1,  
       ["U"] = 2, 
       ["R"] = 3,
       ["E"] = 4,
       ["L"] = 5, 
       ["M"] = 6,
       ["F"] = 7
   }
   
   for _, button in ipairs(RarityFrame:GetChildren()) do
       if button:IsA("TextButton") then
           local rarityNumber = rarityMap[button.Text]
           if rarityNumber and savedSelectedRarities[rarityNumber] then
               button.BackgroundColor3 = Color3.fromRGB(160, 80, 255)
               selectedRarities[rarityNumber] = true
           end
       end
   end
end

local dragStart = nil
local startPos = nil
local guiDragging = false

local function updateDrag(input)
   if guiDragging then
       local delta = input.Position - dragStart
       MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
   end
end

local function updateMapText()
   MapButton.Text = "Map: " .. selectedMap
end

local function updateDifficultyText()
   local difficulties = {"Basic", "Moderate", "Expert", "Arcane", "Calamity"}
   DifficultyButton.Text = "Difficulty: " .. difficulties[selectedDifficulty + 1]
end

local function updateHPText()
   local hpOptions = {[0] = "Infinite", [3] = "3", [1] = "1"}
   HPButton.Text = "HP: " .. hpOptions[selectedHP]
end

local function createDropdown(parent, options, callback)
   local existingDropdown = parent:FindFirstChild("Dropdown")
   if existingDropdown then
       existingDropdown:Destroy()
   end
   
   local dropdown = Instance.new("Frame")
   dropdown.Name = "Dropdown"
   dropdown.Size = UDim2.new(0.9, 0, 0, #options * 25)
   dropdown.Position = UDim2.new(0.05, 0, 1.1, 0)
   dropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
   dropdown.BackgroundTransparency = 0.2
   dropdown.Visible = false
   dropdown.ZIndex = 10
   dropdown.Parent = parent
   
   local UICorner_Dropdown = Instance.new("UICorner")
   UICorner_Dropdown.CornerRadius = UDim.new(0, 8)
   UICorner_Dropdown.Parent = dropdown
   
   for i, option in ipairs(options) do
       local button = Instance.new("TextButton")
       button.Size = UDim2.new(1, 0, 0, 25)
       button.Position = UDim2.new(0, 0, 0, (i-1) * 25)
       button.BackgroundTransparency = 0.6
       button.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
       button.Text = option
       button.Font = Enum.Font.Gotham
       button.TextColor3 = Color3.fromRGB(255, 255, 255)
       button.TextSize = 12
       button.ZIndex = 10
       button.Parent = dropdown
       
       local UICorner_Option = Instance.new("UICorner")
       UICorner_Option.CornerRadius = UDim.new(0, 8)
       UICorner_Option.Parent = button
       
       button.MouseButton1Click:Connect(function()
           callback(i-1, option)
           dropdown.Visible = false
       end)
   end
   
   return dropdown
end

loadSettings()
updateMapText()
updateDifficultyText()
updateHPText()
updateButtonStates()
updateRenderState()

if isStartPressed then
   task.spawn(function()
       local args = {
           [1] = selectedMap,
           [2] = selectedDifficulty,
           [3] = selectedHP,
           [4] = 0
       }
       game:GetService("ReplicatedStorage").PartyCreate:FireServer(unpack(args))
       task.wait(1)
       game:GetService("ReplicatedStorage").PartyStart:FireServer()
   end)
end

MainFrame.InputBegan:Connect(function(input)
   if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
       guiDragging = true
       dragStart = input.Position
       startPos = MainFrame.Position
   end
end)

MainFrame.InputEnded:Connect(function(input)
   if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
       guiDragging = false
   end
end)

MainFrame.InputChanged:Connect(function(input)
   if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
       updateDrag(input)
   end
end)

ToggleButton.MouseButton1Click:Connect(function()
   MainFrame.Visible = not MainFrame.Visible
end)

DiscordButton.MouseButton1Click:Connect(function()
   setclipboard("https://discord.gg/SdWZ9srXJe")
end)

AutoJoinButton.MouseButton1Click:Connect(function()
   JoinFrame.Visible = not JoinFrame.Visible
   SellFrame.Visible = false
   AutoJoinButton.BackgroundColor3 = JoinFrame.Visible and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   AutoSellButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
end)

AutoSellButton.MouseButton1Click:Connect(function()
   SellFrame.Visible = not SellFrame.Visible
   JoinFrame.Visible = false
   AutoSellButton.BackgroundColor3 = SellFrame.Visible and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   AutoJoinButton.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
end)

MapButton.MouseButton1Click:Connect(function()
   local mapDropdown = createDropdown(MapButton, {"Corrupted Forest"}, function(_, option)
       selectedMap = option
       updateMapText()
       saveSettings()
   end)
   mapDropdown.Visible = not mapDropdown.Visible
end)

SellButton.MouseButton1Click:Connect(function()
   isSellPressed = not isSellPressed
   SellButton.BackgroundColor3 = isSellPressed and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   saveSettings()
end)

RetryButton.MouseButton1Click:Connect(function()
   isAutoRetry = not isAutoRetry
   RetryButton.BackgroundColor3 = isAutoRetry and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   saveSettings()
end)

RenderButton.MouseButton1Click:Connect(function()
   isRenderDisabled = not isRenderDisabled
   RenderButton.BackgroundColor3 = isRenderDisabled and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   updateRenderState()
   saveSettings()
end)

LootResetButton.MouseButton1Click:Connect(function()
   isLootReset = not isLootReset
   LootResetButton.BackgroundColor3 = isLootReset and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   saveSettings()
end)

StartButton.MouseButton1Click:Connect(function()
   isStartPressed = not isStartPressed
   StartButton.BackgroundColor3 = isStartPressed and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   if isStartPressed then
       task.spawn(function()
           local args = {
               [1] = selectedMap,
               [2] = selectedDifficulty,
               [3] = selectedHP,
               [4] = 0
           }
           game:GetService("ReplicatedStorage").PartyCreate:FireServer(unpack(args))
           task.wait(1)
           game:GetService("ReplicatedStorage").PartyStart:FireServer()
       end)
   end
   saveSettings()
end)

DifficultyButton.MouseButton1Click:Connect(function()
   local difficultyDropdown = createDropdown(DifficultyButton, {"Basic", "Moderate", "Expert", "Arcane", "Calamity"}, function(value)
       selectedDifficulty = value
       updateDifficultyText()
       saveSettings()
   end)
   difficultyDropdown.Visible = not difficultyDropdown.Visible
end)

HPButton.MouseButton1Click:Connect(function()
   local hpDropdown = createDropdown(HPButton, {"Infinite", "3", "1"}, function(value, option)
       if option == "Infinite" then
           selectedHP = 0
       else
           selectedHP = tonumber(option)
       end
       updateHPText()
       saveSettings()
   end)
   hpDropdown.Visible = not hpDropdown.Visible
end)

AutoAttackButton.MouseButton1Click:Connect(function()
   isAutoAttack = not isAutoAttack
   AutoAttackButton.BackgroundColor3 = isAutoAttack and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   if isAutoAttack and isFarming then
       task.spawn(autoAttack)
   end
   saveSettings()
end)

AutoSpellButton.MouseButton1Click:Connect(function()
   isAutoSpell = not isAutoSpell
   AutoSpellButton.BackgroundColor3 = isAutoSpell and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   if isAutoSpell and isFarming then
       task.spawn(castSpells)
   end
   saveSettings()
end)

FarmButton.MouseButton1Click:Connect(function()
   isFarming = not isFarming
   FarmButton.BackgroundColor3 = isFarming and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
   if isFarming then
       startFarming()
   else
       updateRenderState()
   end
   saveSettings()
end)

RetryButton.BackgroundColor3 = isAutoRetry and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
AutoAttackButton.BackgroundColor3 = isAutoAttack and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
AutoSpellButton.BackgroundColor3 = isAutoSpell and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
FarmButton.BackgroundColor3 = isFarming and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
RenderButton.BackgroundColor3 = isRenderDisabled and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
LootResetButton.BackgroundColor3 = isLootReset and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
StartButton.BackgroundColor3 = isStartPressed and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
SellButton.BackgroundColor3 = isSellPressed and Color3.fromRGB(160, 80, 255)or Color3.fromRGB(100, 50, 200)
SpellDelayButton.BackgroundColor3 = isSpellDelay and Color3.fromRGB(160, 80, 255) or Color3.fromRGB(100, 50, 200)

local BaseGui = game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild("BaseGui")
local Timer = BaseGui:WaitForChild("Timer", 10)

if Timer then
   Timer.Retry:GetPropertyChangedSignal("Visible"):Connect(function()
       if Timer.Retry.Visible and isAutoRetry then
           local args = {
               [1] = true
           }
           game:GetService("ReplicatedStorage").Retry:FireServer(unpack(args))
       end
   end)
end

local InventoryGui = game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild("InventoryGui")
local ItemDrops = InventoryGui:WaitForChild("Item Drops")

ItemDrops:GetPropertyChangedSignal("Visible"):Connect(function()
   if ItemDrops.Visible and isLootReset then
       game.Players.LocalPlayer.Character:BreakJoints()
   end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function()
   if isFarming then
       startFarming()
   end
end)

if isFarming then
   task.spawn(startFarming)
end

task.spawn(function()
   while true do
       task.wait(0.2)
       local player = game.Players.LocalPlayer
       local character = player.Character
       if character then
           local head = character:FindFirstChild("Head")
           if head then
               local statsBar = head:FindFirstChild("StatsBar")
               if statsBar then
                   statsBar:Destroy()
               end
           end
       end
       
       local baseGui = player.PlayerGui:FindFirstChild("BaseGui")
       if baseGui then
           local playerStats = baseGui:FindFirstChild("PlayerStats")
           if playerStats then
               local username = playerStats:FindFirstChild("Username")
               if username then
                   username.Text = "discord.gg/SdWZ9srXJe"
               end
               
               local level = playerStats:FindFirstChild("Level")
               if level then
                   local inner = level:FindFirstChild("Inner")
                   if inner then
                       inner.Level.Text = "K"
                   end
               end
           end
       end
   end
end)

task.spawn(function()
 while wait(5) do
     if isSellPressed and (next(selectedTypes) ~= nil and next(selectedRarities) ~= nil) then
         local inventory = workspace.Inventories[game.Players.LocalPlayer.Name].Items
         local equippedItems = getEquippedAndPinnedItems()
         
         for _, item in pairs(inventory:GetChildren()) do
             if item:IsA("StringValue") then
                 local itemData = item.Value:split(",")
                 local itemName = itemData[1]
                 local itemRarity = tonumber(itemData[2])
                 
                 if not equippedItems[item.Name] and selectedRarities[itemRarity] then
                     local itemInfo = workspace.Items:FindFirstChild(itemName)
                     if itemInfo and itemInfo:FindFirstChild("Info") then
                         local itemType = itemInfo.Info.Value:split(",")[1]
                         if selectedTypes[itemType] then
                             local args = {
                                 [1] = {
                                     [1] = item.Name
                                 }
                             }
                             game:GetService("ReplicatedStorage").SellItem:FireServer(unpack(args))
                             wait(0.1)
                         end
                     end
                 end
             end
         end
     end
 end
end)
